<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Report: Convex decomposition of simple polygons</title>

    <script type="text/javascript">
        class Citation extends HTMLElement {
            constructor() {
                super();
            }

            updateHTML() {
                switch (this.src) {
                    case "agarwal_polygon_2002":
                        this.textContent = `(Agarwal, 2002)`;
                        break;
                    case "chazelle_decomposing_1979":
                        this.textContent = `(Chazelle, 2002)`;
                        break;
                    default:
                        this.textContent = `(${this.src}, nd)`;
                        break;
                }
            }

            connectedCallback() {
                this.src = this.getAttribute("src") ?? "???";
                this.updateHTML();
            }

            attributeChangedCallback(property, oldVal, newVal) {
                console.log(property, oldVal, newVal);
                if (oldVal === newVal) return;
                this[property] = newVal;
                this.updateHTML();
            }

            static get observedAttribute() {
                return [`src`];
            }
        }

        window.customElements.define("c-cite", Citation);
    </script>

    <style>
        img {
            width: 30%;
        }

        table,
        tr,
        td {
            border: solid 1px;
        }
    </style>
</head>

<body>
    <h1>Report: Convex decomposition of simple polygons</h1>

    <h2>Meta:</h2>

    <ul>
        <li>Url to git: <a href="https://github.com/SamClercky/project-compgeom">
                https://github.com/SamClercky/project-compgeom
            </a>
        </li>
        <li>Authors:
            <ul>
                <li>Andreas Declerck</li>
                <li>Célian Glénaz</li>
                <li>Mevel Gilles</li>
            </ul>
        </li>
        <li>Programming language: Java</li>
    </ul>

    <div>
        <strong>Some definitions:</strong>
        <ul>
            <li>
                <strong>Steiner point:</strong> Point which is added to
                facilitate a cut in the polygon.
            </li>
            <li>
                <strong>Reflex point:</strong> Point which is pointed inwards
                and reason why a simple polygon is not a convex hull.
            </li>
            <li>
                <strong>Notch:</strong> Same as a reflex point, and mostly used
                in the description of the Chazelle decomposition.
            </li>
            <li>
                <strong>DCEL:</strong> Double Connected Edge List. Structure that
                facilitates the addition/removal/updating of various vertices/edges/faces.
            </li>
        </ul>
    </div>

    <h2>Description of the project</h2>

    <p>
        The goal of the project is to explore different algorithms for decomposing
        a simple polygon into convex subcomponents. For this project five different
        algorithms are attempted. For this, multiple strategies are examined. The
        first strategy is of not adding any extra points (called Steiner points).
        The algorithms that are attempted with this are simple triangulation and
        greedy decomposition. The second strategy is to allow adding adding extra
        points to ease the decomposition. For this, the Chazelle algorithm, slab
        decomposition and KD decomposition are going to be implemented.
    </p>

    <p>
        To better be able to compare the performance of the different algorithms,
        a Minkovski sums algorithm will be implemented where its first step is to
        decompose the polygons on which the sum will be calculated. Reducing the
        amount of decomposition components will here result generally in better
        performance.
    </p>

    <p>
        Here now follows a more thorough description of the different components of
        the application and its implemented algorithms.
    </p>

    <h3>Triangulation</h3>
    <small><strong>By Célian Glénaz</strong></small>
    <p>
        Our implementation of triangulation is based on the line sweep algorithms seen in the course. The first part is
        to split a simple polygon into multiple Y-monotone polygons by adding carefully chosen edges. The <strong>doubly
            connected edge list</strong> structure has been implemented to easily add edges and provide efficient way to
        represent the newly created polygons. At the end of the first part, the border of each face in the DCEL is a
        y-monotone polygon. Here is an example of result of our application at this stage:
    </p>
    <img src="figures/Ymonotone.png" alt="Y-monotone decomposition">
    <p>
        Then the second part is spliting these polygons into triangles by using another line sweep algorithm with a
        stack. The result for the same polygon looks like this:
    </p>
    <img src="figures/triangulated.png" alt="Triangulation">

    <img src="figures/tri-curl.png">
    <img src="figures/tri-splitjoin.png">
    <img src="figures/tri-zaag.png">

    <h3>Greedy Decomposition</h3>
    <small><strong>By Célian Glénaz</strong></small>
    <p>
        This decomposition uses the triangulation algorithm but stop as soon as there is no more reflex vertex in the
        polygon. To be done.
    </p>

    <img src="figures/greedy-curl.png">
    <img src="figures/greedy-splitjoin.png">
    <img src="figures/greedy-zaag.png">

    <h3>Slab Decomposition</h3>
    <small><strong>By Andreas Declerck</strong></small>

    <p>
        The slab decomposition algorithm is described in <c-cite src="agarwal_polygon_2002" />.
        It works by choosing a direction in which to cut and then on every reflex
        point, cut the polygon up and down following the initial chosen
        direction. For implementation, only cutting along the y-axis is handled.
    </p>

    <p>
        The way this algorithm is implemented is by taking a polygon, categorizing
        all vertices of this simple polygon into the following categories: start, end,
        split, join, reflex point and other points. This information is then used in a
        sweep line algorithm that travels perpendicular to the initial direction
        over the field with the vertices as its events. This is done to maintain a list
        of edges above and below a certain point, so only a limited amount of edges need
        to be tested for intersection. Once an edge above/below a reflex point has been
        found, a cut will be made along the initially chosen direction.
    </p>

    <p>
        For this algorithm, all events are used to update the sweep line structure, and
        maintain an ordered list of all edges currently intersecting with the sweep line.
        The vertices considered reflex points are the vertices that are classified as
        either a split, a join or a reflex point.
    </p>

    <p>
        For a time complexity analysis, categorizing all points and adding them
        to an event queue results in O(n log n). As we need to iterate through
        all points and then put them into a priority queue. Insertion of a cut
        is O(E) with E the number of edges of the part of the polygon that has
        not been cut. The final time complexity of this algorithm is then O(E n + p)
        with E the number of edges in the polygon and n the number of events
        that represent reflex points and p the number of events that do not
        represent reflex points.
    </p>

    <img src="figures/type_of_points.svg" />

    <img src="figures/slab-curl.png">
    <img src="figures/slab-splitjoin.png">
    <img src="figures/slab-zaag.png">

    <h3>KD Decomposition</h3>
    <small><strong>By Andreas Declerck</strong></small>

    <p>
        The KD decomposition is described in <c-cite src="agarwal_polygon_2002" />,
        and has been inspired by KD trees sometimes used to accelerate
        raytracing algorithms (see Physically Based Rendering by Pharr, Jacob
        and Humphreys). The basic idea is to subdivide space by first sorting
        all points along all axis (x,y) and then each step taking the median
        along one of these axis and subdividing along this axis through the
        selected point.
    </p>

    <p>
        For the KD decomposition algorithm, this results in first finding all
        reflex points in the polygon and sorting them along the x- and y-axis.
        Every iteration, the median of the sorted reflex points is selected along
        the current axis. The polygon is then cut along this axis through the
        median point. The resulting pieces after the cut are then handled
        recursively until no more reflex points can be found while alternating
        the selected axis.
    </p>

    <p>
        A invariant that needs to be taken into account, is that once a
        reflex point has been used for a cut, it is not reused for a cut along
        another axis.
    </p>

    <p>
        For the time complexity analysis of this algorithm: Finding all the reflex
        points is O(n) and sorting them along all the axis's is O(n log(n)). For
        the meat of the algorithm, first finding the median along an axis region
        is O(1) ((start + end) / 2). Finding one or possibly two opposite sides
        for making a cut, is done by iterating all edges of the faces adjacent to
        the current reflex point. If an edge is intersecting with the direction of
        the cut, is visible from inside the polygon by the current reflex point and
        is the closest intersection seen from the current reflex point, a cut is
        made from the current reflex point to the intersection with the line
        along the current axis through the current reflex point and the found
        edge. This cut can be made in O(E) with E the number of edges in the common
        face between the reflex point and the cut's destination. Finding the cut's
        destination is O(FE) with F the adjacent faces to the reflex point and E
        the number of edges in these adjacent faces. As it is not guaranteed that
        the cut evenly divides every time the polygon, resulting in having to search
        faces that do not really reduce in size with every cut. This leads to a worst
        case time complexity of n*O(n)=O(n^2). But when considering more favorable
        polygons where cutting, splits a face into 2 more equal parts, it can be said
        that the amortized time becomes O(n log n).
    </p>

    <img src="figures/kd-curl.png">
    <img src="figures/kd-splitjoin.png">
    <img src="figures/kd-zaag.png">

    <h3>Chazelle P-time decomposition algorithm</h3>
    <small><strong>By Mevel Gilles</strong></small>

    <h3>Minkovski sum algorithm</h3>
    <small><strong>By Célian Glénaz</strong></small>

    <p>
        To be done.
    </p>

    <h3>GUI</h3>
    <small><strong>By Andreas Declerck</strong></small>

    <p>
        The GUI is made with Processing in Java for the drawing and interactive part and
        uses Swing for all other menus. It contains a custom layout engine to position
        dynamically the buttons in the menu and displays metrics about a certain
        decomposition.
    </p>

    <p>
        For easy testing and experimenting, it is possible to save and reopen a polygon.
        Saving is done by storing the points of the polygon into a custom file format.
        Doing this allows to experiment with different types of polygons in an automated
        testing bed.
    </p>

    <img src="figures/gui_tour.svg" style="width: 100%" />

    <h2>What has been done</h2>

    <ul>
        <li>Triangulation</li>
        <li>Slab Decomposition (except some edge cases)</li>
        <li>Chazelle P-time decomposition (preprocessing steps)</li>
        <li>GUI</li>
        <li>Greedy Decomposition</li>
        <li>KD decomposition</li>
    </ul>

    <h2>Results</h2>

    <img src="figures/curl.png">
    <img src="figures/splitjoin.png">
    <img src="figures/zaag.png">

    <h3>Decomposition results: Curl</h3>
    <table class="result_table">
        <tr>
            <th>Decomposition</th>
            <th>#vertices (before)</th>
            <th>#vertices (decomposition)</th>
            <th>#faces (decomposition)</th>
            <th>#edges (decomposition)</th>
        </tr>
        <tr>
            <td>Triangle</td>
            <td>30</td>
            <td>30</td>
            <td>18</td>
            <td>114</td>
        </tr>
        <tr>
            <td>Greedy</td>
            <td>30</td>
            <td>30</td>
            <td>28</td>
            <td>114</td>
        </tr>
        <tr>
            <td>Slab</td>
            <td>30</td>
            <td>45</td>
            <td>16</td>
            <td>120</td>
        </tr>
        <tr>
            <td>KD</td>
            <td>30</td>
            <td>46</td>
            <td>17</td>
            <td>124</td>
        </tr>
    </table>

    <h3>Decomposition results: Join/Split</h3>
    <table class="result_table">
        <tr>
            <th>Decomposition</th>
            <th>#vertices (before)</th>
            <th>#vertices (decomposition)</th>
            <th>#faces (decomposition)</th>
            <th>#edges (decomposition)</th>
        </tr>
        <tr>
            <td>Triangle</td>
            <td>10</td>
            <td>10</td>
            <td>8</td>
            <td>34</td>
        </tr>
        <tr>
            <td>Greedy</td>
            <td>10</td>
            <td>10</td>
            <td>7</td>
            <td>32</td>
        </tr>
        <tr>
            <td>Slab</td>
            <td>10</td>
            <td>15</td>
            <td>6</td>
            <td>40</td>
        </tr>
        <tr>
            <td>KD</td>
            <td>10</td>
            <td>14</td>
            <td>5</td>
            <td>36</td>
        </tr>
    </table>

    <h3>Decomposition results: Saw</h3>
    <table class="result_table">
        <tr>
            <th>Decomposition</th>
            <th>#vertices</th>
            <th>#vertices (decomposition)</th>
            <th>#faces (decomposition)</th>
            <th>#edges (decomposition)</th>
        </tr>
        <tr>
            <td>Triangle</td>
            <td>18</td>
            <td>18</td>
            <td>16</td>
            <td>66</td>
        </tr>
        <tr>
            <td>Greedy</td>
            <td>18</td>
            <td>18</td>
            <td>16</td>
            <td>66</td>
        </tr>
        <tr>
            <td>Slab</td>
            <td>18</td>
            <td>28</td>
            <td>11</td>
            <td>76</td>
        </tr>
        <tr>
            <td>KD</td>
            <td>18</td>
            <td>29</td>
            <td>12</td>
            <td>80</td>
        </tr>
    </table>

    <script type="text/javascript">
        const tables = document.querySelectorAll(".result_table");

        for (let table of tables) {
            const rows = table.querySelectorAll("tr");
            for (let row of rows) {
                let numOfVert = parseInt(row.children[1].innerText);
                let numOfVertDecom = parseInt(row.children[2].innerText);
                let numOfFacesDecom = parseInt(row.children[3].innerText);
                let numOfEdgesDecom = parseInt(row.children[4].innerText);

                if (isNaN(numOfVert))
                    continue; // header, skip

                if (numOfVert !== numOfVertDecom) {
                    row.children[2].innerText = `${numOfVertDecom} (${(numOfVertDecom / numOfVert * 100).toFixed(2)}%)`;
                }

                row.children[4].innerText = `${numOfEdgesDecom / 2} (${(numOfEdgesDecom / 2 / numOfVert * 100).toFixed(2)}%)`

                console.log("Found:", numOfVert, numOfVertDecom, numOfEdgesDecom, numOfFacesDecom);
            }
        }
    </script>

    <h2>What still needs to be done</h2>

    <ul>
        <li>Chazelle P-time decomposition</li>
        <li>Minkovski sums</li>
    </ul>

    <h2>References</h2>

    <ul style="list-style: none;">
        <li>
            Agarwal, Pankaj K. and Flato, Eyal and Halperin, Dan. (2002).
            <i>Polygon decomposition for efficient construction of Minkowski sums</i>.
            Computational Geometry, 1-2, 39-61.
            <a style="text-decoration: none;"
                href="https://doi.org/10.1016/S0925-7721(01)00041-4">https://doi.org/10.1016/S0925-7721(01)00041-4</a>
        </li>
        <li>
            Chazelle, Bernard and Dobkin, David. (1979).
            <i>Decomposing a polygon into its convex parts</i>.
            Proceedings of the eleventh annual ACM symposium on Theory of computing - STOC '79. ACM Press.
            <a style="text-decoration: none;"
                href="https://doi.org/10.1145/800135.804396">https://doi.org/10.1145/800135.804396</a>
        </li>
    </ul>
</body>

</html>