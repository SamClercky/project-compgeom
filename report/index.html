<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Preview Report: Convex decomposition of simple polygons</title>

    <script type="text/javascript">
        class Citation extends HTMLElement {
            constructor() {
                super();
            }

            updateHTML() {
                switch (this.src) {
                    case "agarwal_polygon_2002":
                        this.textContent = `(Agarwal, 2002)`;
                        break;
                    case "chazelle_decomposing_1979":
                        this.textContent = `(Chazelle, 2002)`;
                        break;
                    default:
                        this.textContent = `(${this.src}, nd)`;
                        break;
                }
            }

            connectedCallback() {
                this.src = this.getAttribute("src") ?? "???";
                this.updateHTML();
            }

            attributeChangedCallback(property, oldVal, newVal) {
                console.log(property, oldVal, newVal);
                if (oldVal === newVal) return;
                this[property] = newVal;
                this.updateHTML();
            }

            static get observedAttribute() {
                return [`src`];
            }
        }

        window.customElements.define("c-cite", Citation);
    </script>
</head>

<body>
    <h1>Preview Report: Convex decomposition of simple polygons</h1>

    <h2>Meta:</h2>

    <ul>
        <li>Url to git: <a href="https://github.com/SamClercky/project-compgeom">
                https://github.com/SamClercky/project-compgeom
            </a>
        </li>
        <li>Authors:
            <ul>
                <li>Andreas Declerck</li>
                <li>Célian Glénaz</li>
                <li>Mevel Gilles</li>
            </ul>
        </li>
        <li>Programming language: Java</li>
    </ul>

    <div>
        <strong>Some definitions:</strong>
        <ul>
            <li>
                <strong>Steiner point:</strong> Point which is added to
                facilitate a cut in the polygon.
            </li>
            <li>
                <strong>Reflex point:</strong> Point which is pointed inwards
                and reason why a simple polygon is not a convex hull.
            </li>
            <li>
                <strong>Notch:</strong> Same as a reflex point, and mostly used
                in the description of the Chazelle decomposition.
            </li>
            <li>
                <strong>DCEL:</strong> Double Connected Edge List. Structure that
                facilitates the addition/removal/updating of various vertices/edges/faces.
            </li>
        </ul>
    </div>

    <h2>Description of the project</h2>

    <p>
        The goal of the project is to explore different algorithms for decomposing
        a simple polygon into convex subcomponents. For this project five different
        algorithms are attempted. For this, multiple stategies are examined. The
        first stategy is of not adding any extra points (called Steiner points).
        The algorithms that are attempted with this are simple triangulation and
        greedy decomposition. The second strategy is to allow adding adding extra
        points to ease the decomposition. For this, the Chazelle algorithm, slab
        decomposition and KD decomposition are going to be implemented.
    </p>

    <p>
        To better be able to compare the performance of the different algorithms,
        a Minkovski sums algorithm will be implemented where its first step is to
        decompose the polygons on which the sum will be calculated. Reducing the
        amount of decomposition components will here result generally in better
        performance.
    </p>

    <p>
        Here now follows a more thorough description of the different components of
        the application and its implemented algorithms.
    </p>

    <h3>Triangulation</h3>
    <small><strong>By Célian Glénaz</strong></small>
    <p>
        Our implementation of triangulation is based on the linesweep algorithms seen in the course. The first part is
        to split a simple polygon into multiple Y-monotone polygons by adding carefuly choosen edges. The <strong>doubly
            connected edge list</strong> structure has been implemented to easily add edges and provide efficient way to
        represent the newly created polygons. At the end of the first part, the border of each face in the DCEL is a
        y-monotone polygon. Here is an example of result of our application at this stage:
    </p>
    <img src="figures/Ymonotone.png" alt="Y-monotone decomposition">
    <p>
        Then the second part is spliting these polygons into triangles by using another linesweep algorithm with a
        stack. The result for the same polygon looks like this:
    </p>
    <img src="figures/triangulated.png" alt="Triangulation">

    <h3>Greedy Decomposition</h3>
    <small><strong>By Célian Glénaz</strong></small>
    <p>
        This decomposition uses the triangulation algorithm but stop as soon as there is no more reflex vertex in the
        polygon. To be done.
    </p>
    <h3>Slab Decomposition</h3>
    <small><strong>By Andreas Declerck</strong></small>

    <p>
        The slab decomposition algorithm is described in <c-cite src="agarwal_polygon_2002" />.
        It works by chosing a direction in which to cut and then on every reflex
        point, cut the polygon up and down following the initial chosen
        direction.
    </p>

    <p>
        The way this algorithm is implemented is by taking a polygon, categorising
        all vertices of this simple polygon into the following categories: start, end,
        split, join, reflex point and other points. This information is then used in a
        sweepline algorithm that travels perpendicular to the initial direction
        over the field with the vertices as its events. This is done to maintain a list
        of edges above and below a certain point, so only a limited amount of edges need
        to be tested for intersection. Once an edge above/below a reflex point has been
        found, a cut will be made along the initialy chosen direction.
    </p>

    <p>
        For this algorithm, all events are used to update the sweepline structure, and
        maintain an ordered list of all edges currently intersecting with the sweepline.
        The vertices considered reflex points are the vertices that are classified as
        either a split, a join or a reflex point.
    </p>

    <img src="figures/type_of_points.svg" width="100%" />

    <h3>KD Decomposition</h3>
    <small><strong>By Andreas Declerck</strong></small>

    <p>
        To be done.
    </p>

    <h3>Chazelle P-time decomposition algorithm</h3>
    <small><strong>By Mevel Gilles</strong></small>

    <h3>Minkovski sum algorithm</h3>
    <small><strong>By Célian Glénaz</strong></small>

    <p>
        To be done.
    </p>

    <h3>GUI</h3>
    <small><strong>By Andreas Declerck</strong></small>

    <p>
        The GUI is made with Processing in Java for the drawing and interactive part and
        uses Swing for all other menus. It contains a custom layout engine to position
        dynamically the buttons in the menu and displays metrics about a certain
        decomposition.
    </p>

    <p>
        For easy testing and experimenting, it is possible to save and reopen a polygon.
        Saving is done by storing the points of the polygon into a custom file format.
        Doing this allows to experiment with different types of polygons in an automated
        testing bed.
    </p>

    <p>
        Currently the explain button does not yet work.
    </p>

    <img src="figures/gui_tour.png" width="100%" />

    <h2>What has been done</h2>

    <ul>
        <li>Triangulation</li>
        <li>Slab Decomposition (except some edge cases)</li>
        <li>Chazelle P-time decomposition (preprocessing steps)</li>
        <li>GUI</li>
    </ul>

    <h2>What still needs to be done</h2>

    <ul>
        <li>Greedy Decomposition</li>
        <li>KD decomposition</li>
        <li>Chazelle P-time decomposition</li>
        <li>Minkovski sums</li>
        <li>Explain button in GUI</li>
        <li>Generalisation of some parts of the slab decomposition in any direction</li>
    </ul>

    <h2>Reference</h2>

    <ul style="list-style: none;">
        <li>
            Agarwal, Pankaj K. and Flato, Eyal and Halperin, Dan. (2002).
            <i>Polygon decomposition for efficient construction of Minkowski sums</i>.
            Computational Geometry, 1-2, 39-61.
            <a style="text-decoration: none;"
                href="https://doi.org/10.1016/S0925-7721(01)00041-4">https://doi.org/10.1016/S0925-7721(01)00041-4</a>
        </li>
        <li>
            Chazelle, Bernard and Dobkin, David. (1979).
            <i>Decomposing a polygon into its convex parts</i>.
            Proceedings of the eleventh annual ACM symposium on Theory of computing - STOC '79. ACM Press.
            <a style="text-decoration: none;"
                href="https://doi.org/10.1145/800135.804396">https://doi.org/10.1145/800135.804396</a>
        </li>
    </ul>
</body>

</html>